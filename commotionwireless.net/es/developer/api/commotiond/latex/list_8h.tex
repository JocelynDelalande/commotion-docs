\hypertarget{list_8h}{\section{src/list.h File Reference}
\label{list_8h}\index{src/list.\+h@{src/list.\+h}}
}


Commotion double linked-\/list implementation.  


{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stddef.\+h$>$}\\*
{\ttfamily \#include $<$stdint.\+h$>$}\\*
{\ttfamily \#include \char`\"{}debug.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}extern/halloc.\+h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bfseries \+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T}(L)
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\hypertarget{list_8h_aaa6976fe5d65d0c4a2407c22f5ee167b}{typedef struct \hyperlink{struct__listnode__t}{\+\_\+listnode\+\_\+t} {\bfseries \+\_\+listnode\+\_\+t}}\label{list_8h_aaa6976fe5d65d0c4a2407c22f5ee167b}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{list_8h_a611b6228d93f5e81950d646f2fde397f}{{\bfseries \+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T} (16)}\label{list_8h_a611b6228d93f5e81950d646f2fde397f}

\item 
\hypertarget{list_8h_a2b9e9337a37f0b7877e443de999a59c0}{{\bfseries \+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T} (32)}\label{list_8h_a2b9e9337a37f0b7877e443de999a59c0}

\item 
size\+\_\+t \hyperlink{list_8h_a18068652e0bf4be28f6c9e0f89c5954c}{co\+\_\+list\+\_\+length} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list)
\begin{DoxyCompactList}\small\item\em return length (number of objects) of given list \end{DoxyCompactList}\item 
\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$ \hyperlink{list_8h_ac63f8c68538b792ec96a4ed032e94a95}{co\+\_\+list\+\_\+get\+\_\+first} (const \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list)
\begin{DoxyCompactList}\small\item\em return first element of given list \end{DoxyCompactList}\item 
\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$ \hyperlink{list_8h_a26d32ffb6dda6b4c348d0255613dd307}{co\+\_\+list\+\_\+get\+\_\+last} (const \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list)
\begin{DoxyCompactList}\small\item\em return last element of given list \end{DoxyCompactList}\item 
\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$ \hyperlink{list_8h_a53067bb4fab9f78bdc6e69381bbccd16}{co\+\_\+list\+\_\+parse} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, co\+\_\+iter\+\_\+t iter, void $\ast$context)
\begin{DoxyCompactList}\small\item\em process list with given iterator function \end{DoxyCompactList}\item 
int \hyperlink{list_8h_a102c8920e3ec13c06747dc752efd91e7}{co\+\_\+list\+\_\+contains} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$item)
\begin{DoxyCompactList}\small\item\em determine if list contains specified item \end{DoxyCompactList}\item 
int \hyperlink{list_8h_a02a669e051437a627198ba279a71d329}{co\+\_\+list\+\_\+insert\+\_\+before} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$new\+\_\+obj, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$this\+\_\+obj)
\begin{DoxyCompactList}\small\item\em insert new item in list before specified item \end{DoxyCompactList}\item 
int \hyperlink{list_8h_a48a986300141a3f9d9ed777f5196b84c}{co\+\_\+list\+\_\+insert\+\_\+before\+\_\+unsafe} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$new\+\_\+obj, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$this\+\_\+obj)
\begin{DoxyCompactList}\small\item\em insert new item in list before specified item without the list managing the item's memory \end{DoxyCompactList}\item 
int \hyperlink{list_8h_af2087c00f5ac0c31bbd1d0344b1ea2a2}{co\+\_\+list\+\_\+insert\+\_\+after} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$new\+\_\+obj, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$this\+\_\+obj)
\begin{DoxyCompactList}\small\item\em insert new item in list after specified item \end{DoxyCompactList}\item 
int \hyperlink{list_8h_a4c58e2c9dd3c23591a40ba64eb50bed0}{co\+\_\+list\+\_\+insert\+\_\+after\+\_\+unsafe} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$new\+\_\+obj, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$this\+\_\+obj)
\begin{DoxyCompactList}\small\item\em insert new item in list after specified item without the list managing the item's memory \end{DoxyCompactList}\item 
int \hyperlink{list_8h_a805b412bf41959577e7757e000a7a896}{co\+\_\+list\+\_\+prepend} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$new\+\_\+obj)
\begin{DoxyCompactList}\small\item\em insert new item at beginning of list \end{DoxyCompactList}\item 
int \hyperlink{list_8h_ad8acc97475c8e4db057704aa985f3ead}{co\+\_\+list\+\_\+prepend\+\_\+unsafe} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$new\+\_\+obj)
\begin{DoxyCompactList}\small\item\em insert new item at beginning of list without the list managing the item's memory \end{DoxyCompactList}\item 
int \hyperlink{list_8h_ada7536773e05cf3dcb33ab73ac2ef84e}{co\+\_\+list\+\_\+append} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$new\+\_\+obj)
\begin{DoxyCompactList}\small\item\em insert new item at end of list \end{DoxyCompactList}\item 
int \hyperlink{list_8h_afed429ec449f7bd8938b19f1485e0292}{co\+\_\+list\+\_\+append\+\_\+unsafe} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$new\+\_\+obj)
\begin{DoxyCompactList}\small\item\em insert new item at end of list without the list managing the item's memory \end{DoxyCompactList}\item 
\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$ \hyperlink{list_8h_a80fbd77f231ae88663c5d0bb25bdfd6c}{co\+\_\+list\+\_\+delete} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$item)
\begin{DoxyCompactList}\small\item\em delete specified item from list \end{DoxyCompactList}\item 
\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$ \hyperlink{list_8h_a647ff4c713547b65d3fa7a1a7cc7dff7}{co\+\_\+list\+\_\+element} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, const unsigned int index)
\begin{DoxyCompactList}\small\item\em return item at specified position in list \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{list_8h_aa314c1c4f43a8314f499ddc28315bfa0}{co\+\_\+list\+\_\+raw} (char $\ast$output, const size\+\_\+t olen, const \hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list)
\begin{DoxyCompactList}\small\item\em dump raw representation of list \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{list_8h_a07c935572c069373bddadf2907a09b2b}{co\+\_\+list\+\_\+import} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$$\ast$list, const char $\ast$input, const size\+\_\+t ilen)
\begin{DoxyCompactList}\small\item\em import list from raw representation \end{DoxyCompactList}\item 
void \hyperlink{list_8h_a2907df72fdabc2deff63de002fd89841}{co\+\_\+list\+\_\+print\+\_\+indent} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list, int indent)
\begin{DoxyCompactList}\small\item\em print list with indent \end{DoxyCompactList}\item 
int \hyperlink{list_8h_a8023b3512663139ca9d0ef0716ee9a3b}{co\+\_\+list\+\_\+print} (\hyperlink{structco__obj__t}{co\+\_\+obj\+\_\+t} $\ast$list)
\begin{DoxyCompactList}\small\item\em print list \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Commotion double linked-\/list implementation. 

\begin{DoxyAuthor}{Author}
Josh King (jheretic), \href{mailto:jking@chambana.net}{\tt jking@chambana.\+net} 
\end{DoxyAuthor}


\subsection{Macro Definition Documentation}
\hypertarget{list_8h_a18d5013e919b0a282ae4091cb78ad095}{\index{list.\+h@{list.\+h}!\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T@{\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T}}
\index{\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T@{\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T}!list.\+h@{list.\+h}}
\subsubsection[{\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+L\+I\+S\+T(
\begin{DoxyParamCaption}
\item[{}]{L}
\end{DoxyParamCaption}
)}}\label{list_8h_a18d5013e919b0a282ae4091cb78ad095}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keyword}{typedef} \textcolor{keyword}{struct }\_\_attribute\_\_((packed)) \(\backslash\)
  \{ \hyperlink{structco__obj__t}{co\_obj\_t} \_header; uint##L##\_t \_len; \hyperlink{struct__listnode__t}{\_listnode\_t} *\_first; 
      \hyperlink{struct__listnode__t}{\_listnode\_t} *\_last; \} co\_list##L##\_t; \(\backslash\)
  int co\_list##L##\_alloc(\hyperlink{structco__obj__t}{co\_obj\_t} *output); \hyperlink{structco__obj__t}{co\_obj\_t} *\(\backslash\)
  co\_list##L##\_create(\textcolor{keywordtype}{void});
\end{DoxyCode}


\subsection{Function Documentation}
\hypertarget{list_8h_ada7536773e05cf3dcb33ab73ac2ef84e}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+append@{co\+\_\+list\+\_\+append}}
\index{co\+\_\+list\+\_\+append@{co\+\_\+list\+\_\+append}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+append}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+append (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{new\+\_\+obj}
\end{DoxyParamCaption}
)}}\label{list_8h_ada7536773e05cf3dcb33ab73ac2ef84e}


insert new item at end of list 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em new\+\_\+obj} & item to insert \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+insert\+\_\+after(), and co\+\_\+list\+\_\+length().



Referenced by \+\_\+schedule(), \+\_\+watch(), co\+\_\+cmd\+\_\+hook(), co\+\_\+cmd\+\_\+hook\+\_\+str(), co\+\_\+connect(), co\+\_\+iface\+\_\+add(), co\+\_\+list\+\_\+import(), co\+\_\+loop\+\_\+add\+\_\+process(), co\+\_\+loop\+\_\+add\+\_\+socket(), co\+\_\+loop\+\_\+add\+\_\+timer(), co\+\_\+profile\+\_\+add(), co\+\_\+request\+\_\+append(), co\+\_\+request\+\_\+append\+\_\+bin(), co\+\_\+request\+\_\+append\+\_\+int(), co\+\_\+request\+\_\+append\+\_\+str(), co\+\_\+request\+\_\+append\+\_\+uint(), co\+\_\+schema\+\_\+register(), co\+\_\+schema\+\_\+register\+\_\+global(), and co\+\_\+socket\+\_\+receive().


\begin{DoxyCode}
426 \{
427   \textcolor{keywordflow}{if}(\hyperlink{list_8c_a18068652e0bf4be28f6c9e0f89c5954c}{co\_list\_length}(list) == 0)
428   \{
429     \textcolor{comment}{/* First item in list. */}
430     \hyperlink{struct__listnode__t}{\_listnode\_t} *new\_node = \_listnode\_create(new\_obj, \textcolor{keyword}{true});
431     \_co\_list\_set\_first(list, new\_node);
432     \_co\_list\_set\_last(list, new\_node);
433     hattach(new\_node, list);
434     \_co\_list\_increment(list);
435     \textcolor{keywordflow}{return} 1;
436   \}
437   \textcolor{keywordflow}{return} \hyperlink{list_8c_af2087c00f5ac0c31bbd1d0344b1ea2a2}{co\_list\_insert\_after}(list, new\_obj, (\_co\_list\_get\_last\_node(list))->value);
438 \}
\end{DoxyCode}
\hypertarget{list_8h_afed429ec449f7bd8938b19f1485e0292}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+append\+\_\+unsafe@{co\+\_\+list\+\_\+append\+\_\+unsafe}}
\index{co\+\_\+list\+\_\+append\+\_\+unsafe@{co\+\_\+list\+\_\+append\+\_\+unsafe}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+append\+\_\+unsafe}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+append\+\_\+unsafe (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{new\+\_\+obj}
\end{DoxyParamCaption}
)}}\label{list_8h_afed429ec449f7bd8938b19f1485e0292}


insert new item at end of list without the list managing the item's memory 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em new\+\_\+obj} & item to insert \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+insert\+\_\+after(), and co\+\_\+list\+\_\+length().


\begin{DoxyCode}
442 \{
443   \textcolor{keywordflow}{if}(\hyperlink{list_8c_a18068652e0bf4be28f6c9e0f89c5954c}{co\_list\_length}(list) == 0)
444   \{
445     \textcolor{comment}{/* First item in list. */}
446     \hyperlink{struct__listnode__t}{\_listnode\_t} *new\_node = \_listnode\_create(new\_obj, \textcolor{keyword}{false});
447     \_co\_list\_set\_first(list, new\_node);
448     \_co\_list\_set\_last(list, new\_node);
449     hattach(new\_node, list);
450     \_co\_list\_increment(list);
451     \textcolor{keywordflow}{return} 1;
452   \}
453   \textcolor{keywordflow}{return} \hyperlink{list_8c_af2087c00f5ac0c31bbd1d0344b1ea2a2}{co\_list\_insert\_after}(list, new\_obj, (\_co\_list\_get\_last\_node(list))->value);
454 \}
\end{DoxyCode}
\hypertarget{list_8h_a102c8920e3ec13c06747dc752efd91e7}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+contains@{co\+\_\+list\+\_\+contains}}
\index{co\+\_\+list\+\_\+contains@{co\+\_\+list\+\_\+contains}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+contains}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+contains (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{item}
\end{DoxyParamCaption}
)}}\label{list_8h_a102c8920e3ec13c06747dc752efd91e7}


determine if list contains specified item 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em item} & item to search for \\
\hline
\end{DoxyParams}


Referenced by co\+\_\+list\+\_\+insert\+\_\+after(), co\+\_\+list\+\_\+insert\+\_\+after\+\_\+unsafe(), co\+\_\+list\+\_\+insert\+\_\+before(), co\+\_\+list\+\_\+insert\+\_\+before\+\_\+unsafe(), co\+\_\+loop\+\_\+add\+\_\+socket(), and co\+\_\+socket\+\_\+hangup().


\begin{DoxyCode}
259 \{
260   \hyperlink{struct__listnode__t}{\_listnode\_t} * result = \_co\_list\_parse\_node(list, \_co\_list\_contains\_i, (\textcolor{keywordtype}{void} *)item);
261   \textcolor{keywordflow}{if}(result != NULL) \textcolor{keywordflow}{return} 1;
262   \textcolor{keywordflow}{return} 0;
263 \}
\end{DoxyCode}
\hypertarget{list_8h_a80fbd77f231ae88663c5d0bb25bdfd6c}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+delete@{co\+\_\+list\+\_\+delete}}
\index{co\+\_\+list\+\_\+delete@{co\+\_\+list\+\_\+delete}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+delete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf co\+\_\+obj\+\_\+t}$\ast$ co\+\_\+list\+\_\+delete (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{item}
\end{DoxyParamCaption}
)}}\label{list_8h_a80fbd77f231ae88663c5d0bb25bdfd6c}


delete specified item from list 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em item} & item to delete \\
\hline
\end{DoxyParams}


Referenced by \+\_\+unschedule(), co\+\_\+disconnect(), co\+\_\+iface\+\_\+remove(), co\+\_\+loop\+\_\+remove\+\_\+process(), co\+\_\+loop\+\_\+remove\+\_\+socket(), co\+\_\+loop\+\_\+remove\+\_\+timer(), co\+\_\+profile\+\_\+remove(), and co\+\_\+socket\+\_\+hangup().


\begin{DoxyCode}
458 \{
459   \hyperlink{structco__obj__t}{co\_obj\_t} *ret = NULL;
460   \hyperlink{struct__listnode__t}{\_listnode\_t} *current = \_co\_list\_find\_node(list, item);
461   \textcolor{keywordflow}{if}(current != NULL) 
462   \{
463     \textcolor{keywordflow}{if}(\_LIST\_PREV(current) != NULL) 
464       \_LIST\_NEXT(\_LIST\_PREV(current)) = \_LIST\_NEXT(current);
465     \textcolor{keywordflow}{else}
466       \_co\_list\_set\_first(list, \_LIST\_NEXT(current));
467 
468     \textcolor{keywordflow}{if}(\_LIST\_NEXT(current) != NULL) 
469       \_LIST\_PREV(\_LIST\_NEXT(current)) = \_LIST\_PREV(current);
470     \textcolor{keywordflow}{else}
471       \_co\_list\_set\_last(list, \_LIST\_PREV(current));
472 
473     ret = current->value;
474     hattach(current->value, NULL);
475     h\_free(current);
476     \_co\_list\_decrement(list);
477     \textcolor{keywordflow}{return} ret;
478   \}
479   \textcolor{keywordflow}{return} NULL;
480 \}
\end{DoxyCode}
\hypertarget{list_8h_a647ff4c713547b65d3fa7a1a7cc7dff7}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+element@{co\+\_\+list\+\_\+element}}
\index{co\+\_\+list\+\_\+element@{co\+\_\+list\+\_\+element}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+element}]{\setlength{\rightskip}{0pt plus 5cm}{\bf co\+\_\+obj\+\_\+t}$\ast$ co\+\_\+list\+\_\+element (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{const unsigned int}]{index}
\end{DoxyParamCaption}
)}}\label{list_8h_a647ff4c713547b65d3fa7a1a7cc7dff7}


return item at specified position in list 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em index} & number of item to return \\
\hline
\end{DoxyParams}


Referenced by co\+\_\+call(), dispatcher\+\_\+cb(), and olsrd\+\_\+mdp\+\_\+sign().


\begin{DoxyCode}
484 \{
485   CHECK(IS\_LIST(list), \textcolor{stringliteral}{"Not a list object."});
486   \hyperlink{struct__listnode__t}{\_listnode\_t} *next = \_co\_list\_get\_first\_node(list);
487   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0;
488   \textcolor{keywordflow}{if}(next != NULL)
489   \{
490     \textcolor{keywordflow}{for}(i = 0; i < index; i++)
491     \{
492       next = \_LIST\_NEXT(next);
493       \textcolor{keywordflow}{if}(next == NULL) \textcolor{keywordflow}{break};
494     \}
495   \}
496   CHECK(i == index, \textcolor{stringliteral}{"List index not found."});
497   \textcolor{keywordflow}{return} next->value;
498 error:
499   \textcolor{keywordflow}{return} NULL;
500 \}
\end{DoxyCode}
\hypertarget{list_8h_ac63f8c68538b792ec96a4ed032e94a95}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+get\+\_\+first@{co\+\_\+list\+\_\+get\+\_\+first}}
\index{co\+\_\+list\+\_\+get\+\_\+first@{co\+\_\+list\+\_\+get\+\_\+first}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+get\+\_\+first}]{\setlength{\rightskip}{0pt plus 5cm}{\bf co\+\_\+obj\+\_\+t}$\ast$ co\+\_\+list\+\_\+get\+\_\+first (
\begin{DoxyParamCaption}
\item[{const {\bf co\+\_\+obj\+\_\+t} $\ast$}]{list}
\end{DoxyParamCaption}
)}}\label{list_8h_ac63f8c68538b792ec96a4ed032e94a95}


return first element of given list 


\begin{DoxyParams}{Parameters}
{\em list} & list object \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
118 \{
119   \textcolor{keywordflow}{return} (\_co\_list\_get\_first\_node(list))->value;
120 \}
\end{DoxyCode}
\hypertarget{list_8h_a26d32ffb6dda6b4c348d0255613dd307}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+get\+\_\+last@{co\+\_\+list\+\_\+get\+\_\+last}}
\index{co\+\_\+list\+\_\+get\+\_\+last@{co\+\_\+list\+\_\+get\+\_\+last}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+get\+\_\+last}]{\setlength{\rightskip}{0pt plus 5cm}{\bf co\+\_\+obj\+\_\+t}$\ast$ co\+\_\+list\+\_\+get\+\_\+last (
\begin{DoxyParamCaption}
\item[{const {\bf co\+\_\+obj\+\_\+t} $\ast$}]{list}
\end{DoxyParamCaption}
)}}\label{list_8h_a26d32ffb6dda6b4c348d0255613dd307}


return last element of given list 


\begin{DoxyParams}{Parameters}
{\em list} & list object \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
163 \{
164   \textcolor{keywordflow}{return} (\_co\_list\_get\_last\_node(list))->value;
165 \}
\end{DoxyCode}
\hypertarget{list_8h_a07c935572c069373bddadf2907a09b2b}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+import@{co\+\_\+list\+\_\+import}}
\index{co\+\_\+list\+\_\+import@{co\+\_\+list\+\_\+import}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+import}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t co\+\_\+list\+\_\+import (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$$\ast$}]{list, }
\item[{const char $\ast$}]{input, }
\item[{const size\+\_\+t}]{ilen}
\end{DoxyParamCaption}
)}}\label{list_8h_a07c935572c069373bddadf2907a09b2b}


import list from raw representation 


\begin{DoxyParams}{Parameters}
{\em list} & target pointer to new list object \\
\hline
{\em input} & input buffer \\
\hline
{\em ilen} & length of input buffer \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+append(), co\+\_\+list\+\_\+import(), and co\+\_\+tree\+\_\+import().



Referenced by co\+\_\+call(), co\+\_\+list\+\_\+import(), co\+\_\+tree\+\_\+import(), and dispatcher\+\_\+cb().


\begin{DoxyCode}
563 \{
564   \textcolor{keywordtype}{size\_t} length = 0, olen = 0, read = 0;
565   \hyperlink{structco__obj__t}{co\_obj\_t} *obj = NULL;
566   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *cursor = input;
567   \textcolor{keywordflow}{switch}((uint8\_t)input[0])
568   \{
569     \textcolor{keywordflow}{case} \_list16:
570       length = *((uint16\_t *)(input + 1));
571       *list = co\_list16\_create();
572       cursor += \textcolor{keyword}{sizeof}(uint16\_t) + 1;
573       read = \textcolor{keyword}{sizeof}(uint16\_t) + 1;
574       \textcolor{keywordflow}{break};
575     \textcolor{keywordflow}{case} \_list32:
576       length = *((uint32\_t *)(input + 1));
577       *list = co\_list32\_create();
578       cursor += \textcolor{keyword}{sizeof}(uint32\_t) + 1;
579       read = \textcolor{keyword}{sizeof}(uint32\_t) + 1;
580       \textcolor{keywordflow}{break};
581     \textcolor{keywordflow}{default}:
582       SENTINEL(\textcolor{stringliteral}{"Not a list."});
583       \textcolor{keywordflow}{break};
584   \}
585   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; (i < length && read <= ilen); i++)
586   \{
587     \textcolor{keywordflow}{if}(((uint8\_t)cursor[0] == \_list16) || ((uint8\_t)cursor[0] == \_list32))
588     \{
589       olen = \hyperlink{list_8c_a07c935572c069373bddadf2907a09b2b}{co\_list\_import}(&obj, cursor, ilen - read);
590     \}
591     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(((uint8\_t)cursor[0] == \_tree16) || ((uint8\_t)cursor[0] == \_tree32))
592     \{
593       olen = \hyperlink{tree_8c_adce5da6ec6de712ac6f996847fa71b49}{co\_tree\_import}(&obj, cursor, ilen - read);
594     \}
595     \textcolor{keywordflow}{else} olen = co\_obj\_import(&obj, cursor, ilen - read, 0);
596     CHECK(olen > 0, \textcolor{stringliteral}{"Failed to import object."});
597     cursor +=olen;
598     read += olen;
599     CHECK(\hyperlink{list_8c_ada7536773e05cf3dcb33ab73ac2ef84e}{co\_list\_append}(*list, obj), \textcolor{stringliteral}{"Failed to add object to list."});
600   \}
601   \textcolor{keywordflow}{return} read;
602 error:
603   \textcolor{keywordflow}{return} -1;
604 \}
\end{DoxyCode}
\hypertarget{list_8h_af2087c00f5ac0c31bbd1d0344b1ea2a2}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+insert\+\_\+after@{co\+\_\+list\+\_\+insert\+\_\+after}}
\index{co\+\_\+list\+\_\+insert\+\_\+after@{co\+\_\+list\+\_\+insert\+\_\+after}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+insert\+\_\+after}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+insert\+\_\+after (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{new\+\_\+obj, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{this\+\_\+obj}
\end{DoxyParamCaption}
)}}\label{list_8h_af2087c00f5ac0c31bbd1d0344b1ea2a2}


insert new item in list after specified item 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em new\+\_\+obj} & item to insert \\
\hline
{\em this\+\_\+obj} & item to insert after \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+contains().



Referenced by co\+\_\+list\+\_\+append(), and co\+\_\+list\+\_\+append\+\_\+unsafe().


\begin{DoxyCode}
334 \{
335   CHECK(IS\_LIST(list), \textcolor{stringliteral}{"Not a list object."});
336   \hyperlink{struct__listnode__t}{\_listnode\_t} *this\_node = \_co\_list\_find\_node(list, this\_obj);
337   CHECK(this\_node != NULL, \textcolor{stringliteral}{"Unable to find existing node in \(\backslash\)}
338 \textcolor{stringliteral}{specified list."});
339   CHECK(!\hyperlink{list_8c_a102c8920e3ec13c06747dc752efd91e7}{co\_list\_contains}(list, new\_obj), \textcolor{stringliteral}{"New node already in specified \(\backslash\)}
340 \textcolor{stringliteral}{list."});
341   \hyperlink{struct__listnode__t}{\_listnode\_t} *adjacent = \_LIST\_NEXT(this\_node);
342   \hyperlink{struct__listnode__t}{\_listnode\_t} *new\_node = \_listnode\_create(new\_obj, \textcolor{keyword}{true});
343   hattach(new\_node, list);
344   \textcolor{keywordflow}{if}(adjacent == NULL)
345   \{
346     \textcolor{comment}{/* Last in list. */}
347     \_co\_list\_set\_last(list, new\_node);
348   \}
349   \textcolor{keywordflow}{else}
350   \{
351     \_LIST\_PREV(adjacent) = new\_node;
352     \_LIST\_NEXT(new\_node) = adjacent;
353   \}
354   \_LIST\_PREV(new\_node) = this\_node;
355   \_LIST\_NEXT(this\_node) = new\_node;
356   \_co\_list\_increment(list);
357   \textcolor{keywordflow}{return} 1;
358 error:
359   \textcolor{keywordflow}{return} 0;
360 \}
\end{DoxyCode}
\hypertarget{list_8h_a4c58e2c9dd3c23591a40ba64eb50bed0}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+insert\+\_\+after\+\_\+unsafe@{co\+\_\+list\+\_\+insert\+\_\+after\+\_\+unsafe}}
\index{co\+\_\+list\+\_\+insert\+\_\+after\+\_\+unsafe@{co\+\_\+list\+\_\+insert\+\_\+after\+\_\+unsafe}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+insert\+\_\+after\+\_\+unsafe}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+insert\+\_\+after\+\_\+unsafe (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{new\+\_\+obj, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{this\+\_\+obj}
\end{DoxyParamCaption}
)}}\label{list_8h_a4c58e2c9dd3c23591a40ba64eb50bed0}


insert new item in list after specified item without the list managing the item's memory 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em new\+\_\+obj} & item to insert \\
\hline
{\em this\+\_\+obj} & item to insert after \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+contains().


\begin{DoxyCode}
364 \{
365   CHECK(IS\_LIST(list), \textcolor{stringliteral}{"Not a list object."});
366   \hyperlink{struct__listnode__t}{\_listnode\_t} *this\_node = \_co\_list\_find\_node(list, this\_obj);
367   CHECK(this\_node != NULL, \textcolor{stringliteral}{"Unable to find existing node in \(\backslash\)}
368 \textcolor{stringliteral}{specified list."});
369   CHECK(!\hyperlink{list_8c_a102c8920e3ec13c06747dc752efd91e7}{co\_list\_contains}(list, new\_obj), \textcolor{stringliteral}{"New node already in specified \(\backslash\)}
370 \textcolor{stringliteral}{list."});
371   \hyperlink{struct__listnode__t}{\_listnode\_t} *adjacent = \_LIST\_NEXT(this\_node);
372   \hyperlink{struct__listnode__t}{\_listnode\_t} *new\_node = \_listnode\_create(new\_obj, \textcolor{keyword}{false});
373   hattach(new\_node, list);
374   \textcolor{keywordflow}{if}(adjacent == NULL)
375   \{
376     \textcolor{comment}{/* Last in list. */}
377     \_co\_list\_set\_last(list, new\_node);
378   \}
379   \textcolor{keywordflow}{else}
380   \{
381     \_LIST\_PREV(adjacent) = new\_node;
382     \_LIST\_NEXT(new\_node) = adjacent;
383   \}
384   \_LIST\_PREV(new\_node) = this\_node;
385   \_LIST\_NEXT(this\_node) = new\_node;
386   \_co\_list\_increment(list);
387   \textcolor{keywordflow}{return} 1;
388 error:
389   \textcolor{keywordflow}{return} 0;
390 \}
\end{DoxyCode}
\hypertarget{list_8h_a02a669e051437a627198ba279a71d329}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+insert\+\_\+before@{co\+\_\+list\+\_\+insert\+\_\+before}}
\index{co\+\_\+list\+\_\+insert\+\_\+before@{co\+\_\+list\+\_\+insert\+\_\+before}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+insert\+\_\+before}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+insert\+\_\+before (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{new\+\_\+obj, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{this\+\_\+obj}
\end{DoxyParamCaption}
)}}\label{list_8h_a02a669e051437a627198ba279a71d329}


insert new item in list before specified item 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em new\+\_\+obj} & item to insert \\
\hline
{\em this\+\_\+obj} & item to insert before \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+contains().



Referenced by co\+\_\+list\+\_\+prepend(), co\+\_\+list\+\_\+prepend\+\_\+unsafe(), and co\+\_\+loop\+\_\+add\+\_\+timer().


\begin{DoxyCode}
274 \{
275   CHECK(IS\_LIST(list), \textcolor{stringliteral}{"Not a list object."});
276   \hyperlink{struct__listnode__t}{\_listnode\_t} *this\_node = \_co\_list\_find\_node(list, this\_obj);
277   CHECK(this\_node != NULL, \textcolor{stringliteral}{"Unable to find existing node in \(\backslash\)}
278 \textcolor{stringliteral}{specified list."});
279   CHECK(!\hyperlink{list_8c_a102c8920e3ec13c06747dc752efd91e7}{co\_list\_contains}(list, new\_obj), \textcolor{stringliteral}{"New node already in specified \(\backslash\)}
280 \textcolor{stringliteral}{list."});
281   \hyperlink{struct__listnode__t}{\_listnode\_t} *adjacent = \_LIST\_PREV(this\_node);
282   \hyperlink{struct__listnode__t}{\_listnode\_t} *new\_node = \_listnode\_create(new\_obj, \textcolor{keyword}{true});
283   hattach(new\_node, list);
284   \textcolor{keywordflow}{if}(adjacent == NULL)
285   \{
286     \textcolor{comment}{/* First in list. */}
287     \_co\_list\_set\_first(list, new\_node);
288   \}
289   \textcolor{keywordflow}{else}
290   \{
291     \_LIST\_NEXT(adjacent) = new\_node;
292     \_LIST\_PREV(new\_node) = adjacent;
293   \}
294   \_LIST\_NEXT(new\_node) = this\_node;
295   \_LIST\_PREV(this\_node) = new\_node;
296   \_co\_list\_increment(list);
297   \textcolor{keywordflow}{return} 1;
298 error:
299   \textcolor{keywordflow}{return} 0;
300 \}
\end{DoxyCode}
\hypertarget{list_8h_a48a986300141a3f9d9ed777f5196b84c}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+insert\+\_\+before\+\_\+unsafe@{co\+\_\+list\+\_\+insert\+\_\+before\+\_\+unsafe}}
\index{co\+\_\+list\+\_\+insert\+\_\+before\+\_\+unsafe@{co\+\_\+list\+\_\+insert\+\_\+before\+\_\+unsafe}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+insert\+\_\+before\+\_\+unsafe}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+insert\+\_\+before\+\_\+unsafe (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{new\+\_\+obj, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{this\+\_\+obj}
\end{DoxyParamCaption}
)}}\label{list_8h_a48a986300141a3f9d9ed777f5196b84c}


insert new item in list before specified item without the list managing the item's memory 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em new\+\_\+obj} & item to insert \\
\hline
{\em this\+\_\+obj} & item to insert before \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+contains().


\begin{DoxyCode}
304 \{
305   CHECK(IS\_LIST(list), \textcolor{stringliteral}{"Not a list object."});
306   \hyperlink{struct__listnode__t}{\_listnode\_t} *this\_node = \_co\_list\_find\_node(list, this\_obj);
307   CHECK(this\_node != NULL, \textcolor{stringliteral}{"Unable to find existing node in \(\backslash\)}
308 \textcolor{stringliteral}{specified list."});
309   CHECK(!\hyperlink{list_8c_a102c8920e3ec13c06747dc752efd91e7}{co\_list\_contains}(list, new\_obj), \textcolor{stringliteral}{"New node already in specified \(\backslash\)}
310 \textcolor{stringliteral}{list."});
311   \hyperlink{struct__listnode__t}{\_listnode\_t} *adjacent = \_LIST\_PREV(this\_node);
312   \hyperlink{struct__listnode__t}{\_listnode\_t} *new\_node = \_listnode\_create(new\_obj, \textcolor{keyword}{false});
313   hattach(new\_node, list);
314   \textcolor{keywordflow}{if}(adjacent == NULL)
315   \{
316     \textcolor{comment}{/* First in list. */}
317     \_co\_list\_set\_first(list, new\_node);
318   \}
319   \textcolor{keywordflow}{else}
320   \{
321     \_LIST\_NEXT(adjacent) = new\_node;
322     \_LIST\_PREV(new\_node) = adjacent;
323   \}
324   \_LIST\_NEXT(new\_node) = this\_node;
325   \_LIST\_PREV(this\_node) = new\_node;
326   \_co\_list\_increment(list);
327   \textcolor{keywordflow}{return} 1;
328 error:
329   \textcolor{keywordflow}{return} 0;
330 \}
\end{DoxyCode}
\hypertarget{list_8h_a18068652e0bf4be28f6c9e0f89c5954c}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+length@{co\+\_\+list\+\_\+length}}
\index{co\+\_\+list\+\_\+length@{co\+\_\+list\+\_\+length}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+length}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t co\+\_\+list\+\_\+length (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list}
\end{DoxyParamCaption}
)}}\label{list_8h_a18068652e0bf4be28f6c9e0f89c5954c}


return length (number of objects) of given list 


\begin{DoxyParams}{Parameters}
{\em list} & list object \\
\hline
\end{DoxyParams}


Referenced by co\+\_\+list\+\_\+append(), co\+\_\+list\+\_\+append\+\_\+unsafe(), co\+\_\+list\+\_\+prepend(), co\+\_\+list\+\_\+prepend\+\_\+unsafe(), and co\+\_\+plugins\+\_\+shutdown().


\begin{DoxyCode}
215 \{ 
216   \textcolor{keywordflow}{return} \_co\_list\_change\_length(list, 0);
217 \}
\end{DoxyCode}
\hypertarget{list_8h_a53067bb4fab9f78bdc6e69381bbccd16}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+parse@{co\+\_\+list\+\_\+parse}}
\index{co\+\_\+list\+\_\+parse@{co\+\_\+list\+\_\+parse}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+parse}]{\setlength{\rightskip}{0pt plus 5cm}{\bf co\+\_\+obj\+\_\+t}$\ast$ co\+\_\+list\+\_\+parse (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{co\+\_\+iter\+\_\+t}]{iter, }
\item[{void $\ast$}]{context}
\end{DoxyParamCaption}
)}}\label{list_8h_a53067bb4fab9f78bdc6e69381bbccd16}


process list with given iterator function 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em iter} & iterator function \\
\hline
{\em context} & additional arguments to iterator \\
\hline
\end{DoxyParams}


Referenced by \+\_\+schedule(), \+\_\+unschedule(), \+\_\+watch(), co\+\_\+iface\+\_\+get(), co\+\_\+iface\+\_\+profile(), co\+\_\+iface\+\_\+remove(), co\+\_\+list\+\_\+print\+\_\+indent(), co\+\_\+loop\+\_\+add\+\_\+socket(), co\+\_\+loop\+\_\+add\+\_\+timer(), co\+\_\+loop\+\_\+destroy(), co\+\_\+loop\+\_\+get\+\_\+socket(), co\+\_\+loop\+\_\+get\+\_\+timer(), co\+\_\+loop\+\_\+remove\+\_\+process(), co\+\_\+loop\+\_\+remove\+\_\+socket(), co\+\_\+loop\+\_\+remove\+\_\+timer(), co\+\_\+plugins\+\_\+shutdown(), co\+\_\+plugins\+\_\+start(), co\+\_\+profile\+\_\+find(), co\+\_\+profiles\+\_\+process(), co\+\_\+shutdown(), co\+\_\+socket\+\_\+destroy(), and serval\+\_\+socket\+\_\+cb().


\begin{DoxyCode}
234 \{
235   \hyperlink{structco__obj__t}{co\_obj\_t} *result = NULL;
236   CHECK\_MEM(list);
237   CHECK(IS\_LIST(list), \textcolor{stringliteral}{"Not a list object."});
238   \textcolor{comment}{//co\_obj\_t *next = \_LIST\_NEXT(list);}
239   \hyperlink{struct__listnode__t}{\_listnode\_t} *next = \_co\_list\_get\_first\_node(list);
240   \textcolor{keywordflow}{while}(next != NULL && result == NULL)
241   \{
242     result = iter(list, next->value, context);
243     next = \_LIST\_NEXT(next);
244   \}
245   \textcolor{keywordflow}{return} result;
246 error:
247   \textcolor{keywordflow}{return} result;
248 \}
\end{DoxyCode}
\hypertarget{list_8h_a805b412bf41959577e7757e000a7a896}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+prepend@{co\+\_\+list\+\_\+prepend}}
\index{co\+\_\+list\+\_\+prepend@{co\+\_\+list\+\_\+prepend}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+prepend}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+prepend (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{new\+\_\+obj}
\end{DoxyParamCaption}
)}}\label{list_8h_a805b412bf41959577e7757e000a7a896}


insert new item at beginning of list 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em new\+\_\+obj} & item to insert \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+insert\+\_\+before(), and co\+\_\+list\+\_\+length().


\begin{DoxyCode}
394 \{
395   \textcolor{keywordflow}{if}(\hyperlink{list_8c_a18068652e0bf4be28f6c9e0f89c5954c}{co\_list\_length}(list) == 0)
396   \{
397     \textcolor{comment}{/* First item in list. */}
398     \hyperlink{struct__listnode__t}{\_listnode\_t} *new\_node = \_listnode\_create(new\_obj, \textcolor{keyword}{true});
399     \_co\_list\_set\_first(list, new\_node);
400     \_co\_list\_set\_last(list, new\_node);
401     hattach(new\_node, list);
402     \_co\_list\_increment(list);
403     \textcolor{keywordflow}{return} 1;
404   \}
405   \textcolor{keywordflow}{return} \hyperlink{list_8c_a02a669e051437a627198ba279a71d329}{co\_list\_insert\_before}(list, new\_obj, (\_co\_list\_get\_first\_node(list))->value);
406 \}
\end{DoxyCode}
\hypertarget{list_8h_ad8acc97475c8e4db057704aa985f3ead}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+prepend\+\_\+unsafe@{co\+\_\+list\+\_\+prepend\+\_\+unsafe}}
\index{co\+\_\+list\+\_\+prepend\+\_\+unsafe@{co\+\_\+list\+\_\+prepend\+\_\+unsafe}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+prepend\+\_\+unsafe}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+prepend\+\_\+unsafe (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{new\+\_\+obj}
\end{DoxyParamCaption}
)}}\label{list_8h_ad8acc97475c8e4db057704aa985f3ead}


insert new item at beginning of list without the list managing the item's memory 


\begin{DoxyParams}{Parameters}
{\em list} & list object to process \\
\hline
{\em new\+\_\+obj} & item to insert \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+insert\+\_\+before(), and co\+\_\+list\+\_\+length().


\begin{DoxyCode}
410 \{
411   \textcolor{keywordflow}{if}(\hyperlink{list_8c_a18068652e0bf4be28f6c9e0f89c5954c}{co\_list\_length}(list) == 0)
412   \{
413     \textcolor{comment}{/* First item in list. */}
414     \hyperlink{struct__listnode__t}{\_listnode\_t} *new\_node = \_listnode\_create(new\_obj, \textcolor{keyword}{false});
415     \_co\_list\_set\_first(list, new\_node);
416     \_co\_list\_set\_last(list, new\_node);
417     hattach(new\_node, list);
418     \_co\_list\_increment(list);
419     \textcolor{keywordflow}{return} 1;
420   \}
421   \textcolor{keywordflow}{return} \hyperlink{list_8c_a02a669e051437a627198ba279a71d329}{co\_list\_insert\_before}(list, new\_obj, (\_co\_list\_get\_first\_node(list))->value);
422 \}
\end{DoxyCode}
\hypertarget{list_8h_a8023b3512663139ca9d0ef0716ee9a3b}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+print@{co\+\_\+list\+\_\+print}}
\index{co\+\_\+list\+\_\+print@{co\+\_\+list\+\_\+print}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+print}]{\setlength{\rightskip}{0pt plus 5cm}int co\+\_\+list\+\_\+print (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list}
\end{DoxyParamCaption}
)}}\label{list_8h_a8023b3512663139ca9d0ef0716ee9a3b}


print list 


\begin{DoxyParams}{Parameters}
{\em list} & list object to print \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+print\+\_\+indent().


\begin{DoxyCode}
681 \{
682   CHECK\_MEM(list);
683 
684   \hyperlink{list_8c_a2907df72fdabc2deff63de002fd89841}{co\_list\_print\_indent}(list,0);
685   
686   \textcolor{keywordflow}{return} 1;
687 error:
688   \textcolor{keywordflow}{return} 0;
689 \}
\end{DoxyCode}
\hypertarget{list_8h_a2907df72fdabc2deff63de002fd89841}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+print\+\_\+indent@{co\+\_\+list\+\_\+print\+\_\+indent}}
\index{co\+\_\+list\+\_\+print\+\_\+indent@{co\+\_\+list\+\_\+print\+\_\+indent}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+print\+\_\+indent}]{\setlength{\rightskip}{0pt plus 5cm}void co\+\_\+list\+\_\+print\+\_\+indent (
\begin{DoxyParamCaption}
\item[{{\bf co\+\_\+obj\+\_\+t} $\ast$}]{list, }
\item[{int}]{indent}
\end{DoxyParamCaption}
)}}\label{list_8h_a2907df72fdabc2deff63de002fd89841}


print list with indent 


\begin{DoxyParams}{Parameters}
{\em list} & list object to print \\
\hline
{\em indent} & level of indent \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+parse().



Referenced by co\+\_\+list\+\_\+print().


\begin{DoxyCode}
668 \{
669   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < indent; i++) printf(\textcolor{stringliteral}{"  "});
670   printf(\textcolor{stringliteral}{"[\(\backslash\)n"});
671   indent++;
672   \hyperlink{list_8c_a53067bb4fab9f78bdc6e69381bbccd16}{co\_list\_parse}(list, \_co\_list\_print\_i, &indent);
673   indent--;
674   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < indent; i++) printf(\textcolor{stringliteral}{"  "});
675   printf(\textcolor{stringliteral}{"]"});
676   \textcolor{keywordflow}{if} (!indent) printf(\textcolor{stringliteral}{"\(\backslash\)n"});
677 \}
\end{DoxyCode}
\hypertarget{list_8h_aa314c1c4f43a8314f499ddc28315bfa0}{\index{list.\+h@{list.\+h}!co\+\_\+list\+\_\+raw@{co\+\_\+list\+\_\+raw}}
\index{co\+\_\+list\+\_\+raw@{co\+\_\+list\+\_\+raw}!list.\+h@{list.\+h}}
\subsubsection[{co\+\_\+list\+\_\+raw}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t co\+\_\+list\+\_\+raw (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{output, }
\item[{const size\+\_\+t}]{olen, }
\item[{const {\bf co\+\_\+obj\+\_\+t} $\ast$}]{list}
\end{DoxyParamCaption}
)}}\label{list_8h_aa314c1c4f43a8314f499ddc28315bfa0}


dump raw representation of list 


\begin{DoxyParams}{Parameters}
{\em output} & output buffer \\
\hline
{\em olen} & length of output buffer \\
\hline
{\em list} & list object to process \\
\hline
\end{DoxyParams}


References co\+\_\+list\+\_\+raw(), and co\+\_\+tree\+\_\+raw().



Referenced by co\+\_\+list\+\_\+raw(), co\+\_\+request\+\_\+alloc(), and co\+\_\+response\+\_\+alloc().


\begin{DoxyCode}
504 \{
505   \textcolor{keywordtype}{size\_t} written = 0, read = 0;
506   \textcolor{keywordtype}{char} *in = NULL;
507   \textcolor{keywordtype}{char} *out = output;
508   \textcolor{keywordflow}{switch}(CO\_TYPE(list))
509   \{
510     \textcolor{keywordflow}{case} \_list16:
511       memmove(out, &(list->\_type), \textcolor{keyword}{sizeof}(uint8\_t));
512       out += \textcolor{keyword}{sizeof}(uint8\_t);
513       memmove(out, &(((co\_list16\_t *)list)->\_len), \textcolor{keyword}{sizeof}(uint16\_t));
514       out += \textcolor{keyword}{sizeof}(uint16\_t);
515       written = \textcolor{keyword}{sizeof}(uint8\_t) + \textcolor{keyword}{sizeof}(uint16\_t);
516       \textcolor{keywordflow}{break};
517     \textcolor{keywordflow}{case} \_list32:
518       memmove(out, &(list->\_type), \textcolor{keyword}{sizeof}(uint8\_t));
519       out += \textcolor{keyword}{sizeof}(uint8\_t);
520       memmove(out, &(((co\_list32\_t *)list)->\_len), \textcolor{keyword}{sizeof}(uint32\_t));
521       out += \textcolor{keyword}{sizeof}(uint32\_t);
522       written = \textcolor{keyword}{sizeof}(uint8\_t) + \textcolor{keyword}{sizeof}(uint32\_t);
523       \textcolor{keywordflow}{break};
524     \textcolor{keywordflow}{default}:
525       SENTINEL(\textcolor{stringliteral}{"Not a list object."});
526       \textcolor{keywordflow}{break};
527   \}
528   \hyperlink{struct__listnode__t}{\_listnode\_t} *next = \_co\_list\_get\_first\_node(list);
529   \textcolor{keywordflow}{while}(next != NULL && next->value != NULL && written <= olen)
530   \{
531     \textcolor{keywordflow}{if}((CO\_TYPE(next->value) == \_list16) || (CO\_TYPE(next->value) == \_list32))
532     \{
533         read = \hyperlink{list_8c_aa314c1c4f43a8314f499ddc28315bfa0}{co\_list\_raw}(out, olen - written, next->value);
534         CHECK(read >= 0, \textcolor{stringliteral}{"Failed to dump object."});
535         CHECK(read + written < olen, \textcolor{stringliteral}{"Data too large for buffer."});
536     \}
537     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((CO\_TYPE(next->value) == \_tree16) || (CO\_TYPE(next->value) == \_tree32))
538     \{
539         read = \hyperlink{tree_8c_a8fb27da4a74cbfe0ba1d3537e3bd83bd}{co\_tree\_raw}(out, olen - written, next->value);
540         CHECK(read >= 0, \textcolor{stringliteral}{"Failed to dump object."});
541         CHECK(read + written < olen, \textcolor{stringliteral}{"Data too large for buffer."});
542     \}
543     \textcolor{keywordflow}{else}
544     \{
545         read = co\_obj\_raw(&in, next->value);
546         CHECK(read >= 0, \textcolor{stringliteral}{"Failed to dump object."});
547         CHECK(read + written < olen, \textcolor{stringliteral}{"Data too large for buffer."});
548         memmove(out, in, read);
549     \}
550     DEBUG(\textcolor{stringliteral}{"List in: %s, read: %d"}, in, (\textcolor{keywordtype}{int})read);
551     written += read;
552     out += read;
553     next = \_LIST\_NEXT(next);
554   \}
555   \textcolor{keywordflow}{return} written;
556 error:
557   \textcolor{keywordflow}{return} -1;
558   
559 \}
\end{DoxyCode}
